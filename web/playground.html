<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Simulation Playground - Universal Automation Wiki</title>
        <meta
            name="description"
            content="Interactive simulation playground for testing and visualizing automation workflows"
        />
        <link rel="stylesheet" href="/assets/css/main.css" />
        <link rel="stylesheet" href="/assets/css/components.css" />
        <link rel="stylesheet" href="/assets/css/simulation.css" />

        <link rel="icon" href="/favicon.ico" type="image/x-icon" />
        <link rel="preconnect" href="https://fonts.googleapis.com" />
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
        <link
            href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap"
            rel="stylesheet"
        />

        <script src="/assets/js/simulation-validator.js"></script>

        <script src="/assets/js/tutorial.js"></script>
        <script src="/assets/js/tutorial-validator.js"></script>

        <!-- Monaco Editor for JSON syntax highlighting -->
        <script src="https://unpkg.com/monaco-editor@0.44.0/min/vs/loader.js"></script>

        <style>
            html,
            body {
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden; /* Prevents the main page scrollbar */
            }

            body {
                display: flex;
                flex-direction: column; /* Stack header and main content vertically */
            }

            .playground-main {
                flex: 1;
                min-height: 0;
            }

            .playground-container {
                height: 100vh;
                display: flex;
                flex-direction: column;
                background: var(--bg-color);
            }

            .playground-header {
                background: rgba(255, 255, 255, 0.98);
                backdrop-filter: blur(10px);
                box-shadow: var(--shadow-sm);
                padding: 0.5rem 0;
                height: 50px;
                position: sticky;
                top: 0;
                z-index: 1000;
            }

            .playground-header .header-container {
                display: flex;
                align-items: center;
                height: 100%;
                max-width: 100%;
                padding: 0 var(--spacing-md);
                gap: 1rem;
            }

            .playground-header .logo {
                display: flex;
                align-items: center;
                height: 40px;
                max-width: 200px;
            }

            .playground-header .logo a {
                display: flex;
                align-items: center;
                height: 100%;
                text-decoration: none;
            }

            .playground-header .logo img {
                height: auto;
                max-height: 100%;
                width: auto;
                max-width: 100%;
                object-fit: contain;
            }

            .playground-header h1 {
                margin: 0;
                font-size: var(--font-size-xl);
                font-weight: 600;
                color: #126ca8;
            }

            .header-actions {
                display: flex;
                align-items: center;
                gap: 0.75rem;
                margin-left: auto;
            }

            .json-editor-buttons {
                display: flex;
                gap: 0.25rem;
                padding-right: 0.75rem;
                border-right: 1px solid var(--border-color);
            }

            .simulation-buttons {
                display: flex;
                gap: 0.25rem;
                padding-right: 0.75rem;
                border-right: 1px solid var(--border-color);
            }

            .control-buttons {
                display: flex;
                gap: 0.25rem;
                padding-right: 0.75rem;
                border-right: 1px solid var(--border-color);
            }

            .action-buttons {
                display: flex;
                gap: 0.25rem;
            }

            .header-actions .action-btn {
                padding: 0.25rem 0.5rem;
                font-size: 0.875rem;
                border: 1px solid var(--primary-color);
                background: var(--primary-color);
                color: white;
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .header-actions .action-btn:hover {
                background: var(--primary-dark);
                border-color: var(--primary-dark);
            }

            .header-actions button {
                padding: 0.25rem 0.5rem;
                font-size: 0.875rem;
                border: 1px solid var(--border-color);
                background: white;
                color: var(--text-color);
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .header-actions button:hover {
                background: var(--bg-light);
                border-color: var(--primary-color);
            }

            .header-actions button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
            }

            .header-actions button.primary {
                background: var(--primary-color);
                color: white;
                border-color: var(--primary-color);
            }

            .header-actions button.primary:hover {
                background: var(--primary-dark);
                border-color: var(--primary-dark);
            }

            .playground-main {
                flex: 1;
                display: flex;
                flex-direction: row;
                overflow: hidden;
                position: relative;
            }

            .playground-top {
                height: 70%;
                display: flex;
                border-bottom: 2px solid var(--border-color);
                position: relative;
            }

            .json-editor-panel {
                width: 40%;
                display: flex;
                flex-direction: column;
                border-right: 2px solid var(--border-color);
                position: relative;
            }

            .simulation-panel {
                width: 60%;
                display: flex;
                flex-direction: column;
            }

            .resize-handle-vertical {
                position: absolute;
                top: 0;
                right: -3px;
                bottom: 0;
                width: 6px;
                cursor: col-resize;
                background: transparent;
                z-index: 10;
            }

            .resize-handle-vertical:hover {
                background: rgba(0, 123, 255, 0.3);
            }

            .resize-handle-horizontal {
                position: absolute;
                left: 0;
                right: 0;
                height: 12px;
                cursor: row-resize;
                background: transparent;
                z-index: 10;
                top: -6px;
                width: 100%;
            }

            .resize-handle-horizontal:hover {
                background: rgba(0, 123, 255, 0.3);
            }

            .panel-header {
                display: none;
            }

            .panel-content {
                flex: 1;
                overflow: hidden;
                position: relative;
            }

            #json-editor {
                height: 100%;
                width: 100%;
            }

            .simulation-content {
                height: 100%;
                overflow-y: auto;
                padding: 0.75rem;
                width: 100%;
                box-sizing: border-box;
                display: block !important;
                grid-template-columns: unset !important;
                user-select: none;
            }

            .playground-bottom {
                height: 30%;
                background: var(--bg-light);
                border-top: 1px solid var(--border-color);
                overflow-y: auto;
                position: relative;
                flex-shrink: 0;
            }

            .validation-panel {
                padding: 1rem;
            }

            .validation-header {
                font-weight: 600;
                margin-bottom: 0.5rem;
                color: var(--text-color);
            }

            .validation-content {
                font-family: "Monaco", "Menlo", "Ubuntu Mono", monospace;
                font-size: 0.875rem;
                line-height: 1.4;
            }

            .validation-error {
                color: var(--error-color);
                background: rgba(220, 53, 69, 0.1);
                padding: 0.5rem;
                border-radius: var(--border-radius-sm);
                margin: 0.25rem 0;
            }

            .validation-success {
                color: var(--success-color);
                background: rgba(40, 167, 69, 0.1);
                padding: 0.5rem;
                border-radius: var(--border-radius-sm);
                margin: 0.25rem 0;
            }

            .validation-warning {
                color: #856404;
                background: rgba(255, 193, 7, 0.1);
                padding: 0.5rem;
                border-radius: var(--border-radius-sm);
                margin: 0.25rem 0;
            }

            .toolbar {
                display: flex;
                gap: 0.5rem;
            }

            .toolbar button {
                background: var(--primary-light);
                color: white;
                border: none;
                padding: 0.5rem 1rem;
                border-radius: var(--border-radius-sm);
                cursor: pointer;
                font-size: var(--font-size-sm);
                transition: background-color var(--transition-normal);
            }

            .toolbar button:hover {
                background: var(--primary-dark);
            }

            .toolbar button:disabled {
                background: var(--text-lighter);
                cursor: not-allowed;
            }

            .toolbar button.hidden {
                display: none;
            }

            .loading-overlay {
                position: absolute;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(255, 255, 255, 0.8);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10;
            }

            .spinner {
                width: 40px;
                height: 40px;
                border: 4px solid var(--border-color);
                border-top: 4px solid var(--primary-color);
                border-radius: 50%;
                animation: spin 1s linear infinite;
            }

            @keyframes spin {
                0% {
                    transform: rotate(0deg);
                }
                100% {
                    transform: rotate(360deg);
                }
            }

            .simulation-container {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                display: block !important;
            }

            .simulation-timeline {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                display: block !important;
            }

            .task-track {
                width: 100%;
                max-width: 100%;
                box-sizing: border-box;
                transition: all 0.2s ease;
            }

            .actor-lanes {
                width: 100%;
                box-sizing: border-box;
                display: block !important;
            }

            .actor-lane {
                width: 100%;
                box-sizing: border-box;
                display: flex !important;
            }

            .task-block {
                display: flex;
                align-items: center;
                justify-content: center !important;
                padding: 0.25rem 0.5rem;
                gap: 0.25rem;
                cursor: pointer;
                user-select: none;
                transition: all 0.2s ease;
                background: white;
                color: black;
                border: 2px solid var(--primary-color);
            }

            .task-block:hover {
                border: 2px solid var(--primary-color);
                transform: translateY(-2px);
                box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
                z-index: 5;
            }

            .task-block.dragging {
                opacity: 0.8;
                z-index: 1000;
                pointer-events: none;
                box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            }

            .task-block.resizing {
                opacity: 0.9;
                z-index: 1000;
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            /* Resize handles */
            .task-block::before,
            .task-block::after {
                content: "";
                position: absolute;
                top: 0;
                bottom: 0;
                width: 8px;
                cursor: ew-resize;
                z-index: 10;
                background: transparent;
                transition: background-color 0.2s ease;
            }

            .task-block::before {
                left: -4px;
            }

            .task-block::after {
                right: -4px;
            }

            .task-block:hover::before,
            .task-block:hover::after {
                background-color: rgba(var(--primary-color-rgb), 0.3);
            }

            .task-block.resizing::before,
            .task-block.resizing::after {
                background-color: rgba(var(--primary-color-rgb), 0.5);
            }

            /* Duration preview overlay */
            .duration-preview {
                position: absolute;
                top: -25px;
                left: 50%;
                transform: translateX(-50%);
                background: var(--primary-color);
                color: white;
                padding: 2px 6px;
                border-radius: 3px;
                font-size: 0.7rem;
                white-space: nowrap;
                z-index: 1001;
                pointer-events: none;
            }

            .duration-preview::after {
                content: "";
                position: absolute;
                top: 100%;
                left: 50%;
                transform: translateX(-50%);
                border: 3px solid transparent;
                border-top-color: var(--primary-color);
            }

            .task-emoji {
                font-size: 1.2rem;
                flex-shrink: 0;
                text-align: center;
            }

            /* Dialog styles */
            .dialog-overlay {
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0, 0, 0, 0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 2000;
            }

            .dialog {
                background: white;
                border-radius: var(--border-radius-md);
                padding: 2rem;
                max-width: 500px;
                width: 90%;
                max-height: 80vh;
                overflow-y: auto;
                box-shadow: var(--shadow-lg);
            }

            .dialog h3 {
                margin: 0 0 1.5rem 0;
                color: var(--text-color);
                font-size: var(--font-size-lg);
            }

            .dialog-form {
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }

            .dialog-field {
                display: flex;
                flex-direction: column;
                gap: 0.5rem;
            }

            .dialog-field label {
                font-weight: 500;
                color: var(--text-color);
            }

            .dialog-field input,
            .dialog-field select,
            .dialog-field textarea {
                padding: 0.5rem;
                border: 1px solid var(--border-color);
                border-radius: var(--border-radius-sm);
                font-size: var(--font-size-base);
            }

            .dialog-field textarea {
                resize: vertical;
                min-height: 80px;
            }

            .dialog-buttons {
                display: flex;
                gap: 1rem;
                justify-content: flex-end;
                margin-top: 1.5rem;
            }

            .dialog-buttons button {
                padding: 0.5rem 1rem;
                border: none;
                border-radius: var(--border-radius-sm);
                font-size: var(--font-size-base);
                cursor: pointer;
                transition: all 0.2s ease;
            }

            .dialog-buttons .btn-primary {
                background: var(--primary-color);
                color: white;
            }

            .dialog-buttons .btn-primary:hover {
                background: var(--primary-dark);
            }

            .dialog-buttons .btn-secondary {
                background: var(--bg-light);
                color: var(--text-color);
                border: 1px solid var(--border-color);
            }

            .dialog-buttons .btn-secondary:hover {
                background: var(--border-color);
            }

            .fullscreen-btn {
                padding: 0.25rem 0.5rem;
                font-size: 0.875rem;
                border: 1px solid var(--border-color);
                background: white;
                color: var(--text-color);
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s;
                width: 32px;
                height: 32px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .fullscreen-btn:hover {
                background: var(--bg-light);
                border-color: var(--primary-color);
            }

            .json-editor-panel.hidden {
                display: none;
            }

            .simulation-panel.fullscreen {
                flex: 1;
            }

            /* Submit dialog specific styles */
            .submit-dialog {
                min-width: 400px;
            }

            .cascade-container {
                display: flex;
                flex-direction: column;
                gap: 1rem;
            }

            .cascade-dropdown {
                display: none;
            }

            .cascade-dropdown.visible {
                display: flex;
            }

            .page-path-preview {
                background: var(--bg-light);
                padding: 0.5rem;
                border-radius: var(--border-radius-sm);
                font-family: monospace;
                font-size: 0.9rem;
                margin-top: 0.5rem;
                border: 1px solid var(--border-color);
            }

            .task-duration {
                font-size: 0.7rem;
                opacity: 0.8;
                flex-shrink: 0;
            }

            .validation-inline {
                display: inline-flex;
                align-items: center;
                gap: 0.5rem;
            }

            .validation-indicator {
                display: inline-flex;
                align-items: center;
                gap: 0.25rem;
                padding: 0.25rem 0.5rem;
                border-radius: var(--border-radius-sm);
                font-size: 0.75rem;
                font-weight: 500;
            }

            .validation-indicator.success {
                background: rgba(40, 167, 69, 0.1);
                color: var(--success-color);
            }

            .validation-indicator.warning {
                background: rgba(255, 193, 7, 0.1);
                color: #856404;
            }

            .validation-indicator.error {
                background: rgba(220, 53, 69, 0.1);
                color: var(--error-color);
            }

            .validation-categories {
                display: flex;
                flex-wrap: wrap;
                gap: 1rem;
                margin-top: 1rem;
            }

            .validation-category {
                background: var(--bg-light);
                border-radius: var(--border-radius-md);
                padding: 1rem;
                border-left: 4px solid;
                flex: 1;
                min-width: 300px;
            }

            .validation-category.critical-errors {
                border-left-color: var(--error-color);
            }

            .validation-category.resource-issues {
                border-left-color: #ffc107;
            }

            .validation-category.scheduling-conflicts {
                border-left-color: #fd7e14;
            }

            .validation-category.optimization-suggestions {
                border-left-color: #0dcaf0;
            }

            .validation-category h4 {
                margin: 0 0 0.5rem 0;
                font-size: 0.9rem;
                font-weight: 600;
            }

            .validation-issue {
                background: white;
                border-radius: var(--border-radius-sm);
                padding: 0.5rem;
                margin-bottom: 0.5rem;
                font-size: 0.8rem;
                border-left: 3px solid;
            }

            .validation-issue.error {
                border-left-color: var(--error-color);
            }

            .validation-issue.warning {
                border-left-color: #ffc107;
            }

            .validation-issue.info {
                border-left-color: #0dcaf0;
            }

            /* Enhanced features styling */
            .json-highlight {
                background-color: #ffeb3b !important;
                animation: highlight-fade 2s ease-out;
            }

            @keyframes highlight-fade {
                0% {
                    background-color: #ffeb3b !important;
                }
                100% {
                    background-color: transparent !important;
                }
            }

            .task-track.drop-zone {
                background: rgba(0, 123, 255, 0.1) !important;
                border: 2px dashed var(--primary-color) !important;
            }

            .task-track.drop-zone.invalid {
                background: rgba(220, 53, 69, 0.1) !important;
                border: 2px dashed var(--error-color) !important;
            }

            .resources-panel {
                background: var(--bg-light);
                border-radius: var(--border-radius-sm);
                padding: 0.5rem;
                margin: 0.5rem 0;
                border: 1px solid var(--border-color);
            }

            .resources-panel h5 {
                margin: 0 0 0.5rem 0;
                color: var(--text-color);
                font-size: 0.875rem;
                font-weight: 600;
            }

            .resource-grid {
                display: grid;
                grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
                gap: 0.375rem;
            }

            .resource-item {
                background: white;
                border-radius: var(--border-radius-sm);
                padding: 0.375rem 0.5rem;
                border: 1px solid var(--border-color);
                display: flex;
                align-items: center;
                gap: 0.375rem;
                font-size: 0.75rem;
            }

            .resource-emoji {
                font-size: 1rem;
                flex-shrink: 0;
            }

            .resource-info {
                flex: 1;
                min-width: 0;
            }

            .resource-name {
                font-weight: 600;
                margin: 0;
                font-size: 0.75rem;
                line-height: 1.2;
                white-space: nowrap;
                overflow: hidden;
                text-overflow: ellipsis;
            }

            .resource-state {
                font-size: 0.7rem;
                padding: 0.125rem 0.25rem;
                border-radius: var(--border-radius-sm);
                font-weight: 500;
                line-height: 1;
                margin-top: 0.125rem;
                display: inline-block;
            }

            .resource-state.clean {
                background: rgba(40, 167, 69, 0.1);
                color: var(--success-color);
            }

            .resource-state.dirty {
                background: rgba(220, 53, 69, 0.1);
                color: var(--error-color);
            }

            .resource-state.available {
                background: rgba(0, 123, 255, 0.1);
                color: var(--primary-color);
            }

            .resource-state.in-use {
                background: rgba(255, 193, 7, 0.1);
                color: #856404;
            }

            .undo-button {
                padding: 0.25rem 0.5rem;
                font-size: 0.875rem;
                border: 1px solid var(--border-color);
                background: white;
                color: var(--text-color);
                border-radius: 4px;
                cursor: pointer;
                transition: all 0.2s;
            }

            .undo-button:hover {
                background: var(--bg-light);
                border-color: var(--primary-color);
            }

            .undo-button:disabled {
                opacity: 0.5;
                cursor: not-allowed;
                background: white;
                border-color: var(--border-color);
            }
            /* Tutorial & Gamification Styles */
.tutorial-panel {
    display: none; /* Hidden by default */
    width: 350px;
    flex-shrink: 0; /* Prevent the panel from shrinking */
    background: #fff;
    z-index: 1500;
    box-shadow: 0 0 20px rgba(0,0,0,0.2);
    flex-direction: column;
    border-right: 1px solid var(--border-color);
}
.tutorial-panel.visible {
    display: flex; /* Show the panel and let it take up space */
}
.tutorial-header { padding: 1rem; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; }
.tutorial-header h3 { margin: 0; }
.tutorial-exit-btn { background: none; border: none; font-size: 1.5rem; cursor: pointer; color: var(--text-light); }
.tutorial-exit-btn:hover { color: var(--text-color); }
.tutorial-content { flex: 1; padding: 1rem; overflow-y: auto; line-height: 1.6; }
.tutorial-content code { background: var(--bg-light); padding: 2px 5px; border-radius: 4px; font-family: monospace; }
.tutorial-footer { padding: 1rem; border-top: 1px solid var(--border-color); display: flex; justify-content: space-between; }
.tutorial-footer button { padding: 0.5rem 1rem; border: 1px solid var(--border-color); background: var(--bg-light); cursor: pointer; border-radius: var(--border-radius-sm); }
.tutorial-footer button:disabled { background: var(--border-color); color: var(--text-light); cursor: not-allowed; }
.tutorial-footer button#tutorial-next-btn { background: var(--primary-color); color: white; border-color: var(--primary-color); }
.tutorial-footer button#tutorial-next-btn:disabled { background: var(--primary-light); border-color: var(--primary-light); }

/* Hide buttons when tutorial is active */
body.tutorial-active #load-sample-btn,
body.tutorial-active #render-simulation-btn,
body.tutorial-active #submit-btn,
body.tutorial-active #auto-render-toggle {
    display: none;
}

/* Help Dropdown Styles */
.dropdown { position: relative; display: inline-block; }
.dropdown-content { display: none; position: absolute; background-color: #f9f9f9; min-width: 160px; box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2); z-index: 1; border-radius: var(--border-radius-sm); overflow: hidden; right: 0; }
.dropdown-content a { color: black; padding: 12px 16px; text-decoration: none; display: block; }
.dropdown-content a:hover { background-color: #f1f1f1; }
.dropdown:hover .dropdown-content { display: block; }
        </style>
    </head>
    <body>
        <header class="playground-header">
            <div class="container header-container">
                <div class="logo">
                    <a href="/index">
                        <img
                            src="/assets/images/logo-abbrev-inline.svg"
                            alt="Universal Automation Wiki Logo"
                        />
                    </a>
                </div>
                <h1 class="special-title">Playground</h1>
                <div class="header-actions">
                    <div class="json-editor-buttons">
                        <button id="load-sample-btn">Load Sample</button>
                        <button id="format-json-btn">Format JSON</button>
                        <button id="clear-editor-btn">Clear</button>
                    </div>

                    <div class="simulation-buttons">
                        <button class="action-btn" id="add-task-btn">
                            + Task
                        </button>
                        <button class="action-btn" id="add-actor-btn">
                            + Actor
                        </button>
                        <button class="action-btn" id="add-resource-btn">
                            + Resource
                        </button>
                    </div>

                    <div class="control-buttons">
                        <button id="render-simulation-btn" class="hidden">
                            Render
                        </button>
                        <button id="auto-render-toggle">Auto-render: ON</button>
                        <button
                            id="fullscreen-btn"
                            class="fullscreen-btn primary"
                            title="Toggle fullscreen simulation view"
                        >
                            ‚õ∂
                        </button>
                        <button
                            id="undo-btn"
                            class="undo-button"
                            disabled
                            title="Undo last change (Ctrl+Z)"
                        >
                            ‚Ü∂ Undo
                        </button>
                    </div>

                    <div class="action-buttons">
                        <!-- New Help Dropdown Menu -->
<div class="dropdown">
    <button class="action-btn">Help</button>
    <div class="dropdown-content">
        <a href="#" id="start-tutorial-btn">Start Tutorial</a>
        <a href="#" id="start-llm-btn">Experimental LLM</a>
    </div>
</div>

<button id="submit-btn" class="action-btn" title="Submit simulation to page">Submit</button>
                    </div>
                </div>
            </div>
        </header>

        <main class="playground-main">
            <div id="tutorial-panel" class="tutorial-panel">
                <div class="tutorial-header">
                    <h3 id="tutorial-title">Tutorial</h3>
                    <button id="tutorial-exit-btn" class="tutorial-exit-btn" title="Exit Tutorial">√ó</button>
                </div>
                <div class="tutorial-content">
                    <div id="tutorial-instructions"></div>
                    <div id="tutorial-status" style="display: none; margin-top: 1rem;"></div>
                </div>
                <div class="tutorial-footer">
                    <button id="tutorial-prev-btn">Back</button>
                    <button id="tutorial-next-btn" disabled>Next</button>
                </div>
            </div>
            
            <div style="display: flex; flex-direction: column; flex: 1; min-width: 0;">
                <div class="playground-top">
                    <div class="json-editor-panel">
                        <div class="panel-header"></div>
                        <div class="panel-content">
                            <div id="json-editor"></div>
                        </div>
                        <div class="resize-handle-vertical"></div>
                    </div>

                    <div class="simulation-panel">
                        <div class="panel-header"></div>
                        <div class="panel-content">
                            <div class="simulation-content" id="simulation-content">
                                <p
                                    style="
                                        color: var(--text-light);
                                        text-align: center;
                                        margin-top: 2rem;
                                    "
                                >
                                    Simulation will render automatically as you edit
                                    the JSON. Click on task blocks to jump to their
                                    JSON definition. Drag task blocks to move them
                                    between actors or change times.
                                </p>
                            </div>
                            <div
                                class="loading-overlay"
                                id="simulation-loading"
                                style="display: none"
                            >
                                <div class="spinner"></div>
                            </div>
                        </div>
                    </div>
                </div>

                <div class="playground-bottom">
                    <div class="resize-handle-horizontal"></div>
                    <div class="validation-panel">
                        <div class="validation-header">
                            <div class="validation-inline">
                                <span>Validation</span>
                                <div
                                    class="validation-indicator success"
                                    id="json-status"
                                    title="Click for details"
                                >
                                    ‚úì Valid JSON
                                </div>
                            </div>
                        </div>
                        <div class="validation-content" id="validation-content">
                            <div
                                class="validation-categories"
                                id="validation-categories"
                            >
                                <!-- Validation results will be populated here -->
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </main>

        <!-- Dialog overlay -->
        <div id="dialog-overlay" class="dialog-overlay" style="display: none">
            <div class="dialog" id="dialog-content">
                <!-- Dialog content will be inserted here -->
            </div>
        </div>

        <!-- Overlay 1: Information and Prerequisite Check (Updated) -->
<div id="llm-info-overlay" class="dialog-overlay" style="display: none;">
    <div class="dialog">
        <h3>üöÄ Experimental AI Feature (Canary)</h3>
        <p>You are about to test UAW's integration with an experimental, built-in AI. This feature uses the new Prompt API which is under active development.</p>
        
        <strong>Requirements:</strong>
        <ul>
            <li>You must be using <strong>Google Chrome Canary</strong>.</li>
            <li>The API must be enabled via a feature flag.</li>
        </ul>
        
        <strong>How to Enable:</strong>
        <ol>
            <li>Download and install <a href="https://www.google.com/chrome/canary/" target="_blank">Google Chrome Canary</a>.</li>
            <li>In Canary, go to <code>chrome://flags/#prompt-api-for-gemini-nano</code> <strong>and</strong> <code>chrome://flags/#optimization-guide-on-device-model</code>, set both to <strong>Enabled</strong>, and restart the browser.</li>
            <li>After around 15 minutes, you should see a new entry in <code>chrome://components/</code> - Optimization Guide On Device Model. Wait for this to be on 'Status - Updated' before clicking continue.</li>
        </ol>
        <p><small>This API is experimental and subject to change. It may not work on all devices.</small></p>

        <div class="dialog-buttons">
            <button type="button" class="btn-secondary" id="llm-cancel-btn">Cancel</button>
            <button type="button" class="btn-primary" id="llm-proceed-btn">Continue</button>
        </div>
    </div>
</div>

<!-- Overlay 2: The Chat Interface (No changes needed) -->
<div id="llm-chat-overlay" class="dialog-overlay" style="display: none;">
    <div class="dialog" style="max-width: 600px; display: flex; flex-direction: column;">
        <h3 id="llm-chat-title">Chat with Built-in AI</h3>
        <div id="llm-chat-history" style="flex: 1; overflow-y: auto; border: 1px solid var(--border-color); padding: 1rem; border-radius: 4px; min-height: 300px; margin-bottom: 1rem;"></div>
        <div id="llm-thinking-indicator" style="display: none; font-style: italic; color: var(--text-light); margin-bottom: 1rem;">AI is thinking...</div>
        <form id="llm-chat-form">
            <div style="display: flex; gap: 1rem;">
                <input type="text" id="llm-chat-input" placeholder="Ask a question about your simulation..." style="flex: 1;">
                <button type="submit" class="btn-primary">Send</button>
            </div>
        </form>
         <div class="dialog-buttons" style="justify-content: center;">
            <button type="button" class="btn-secondary" id="llm-chat-close-btn">Close</button>
        </div>
    </div>
</div>

        <script>
            // Enhanced Simulation Playground JavaScript
            let editor;
            let tutorialManager;
            let tutorialData = null;
            let metricsCatalog = [];
            Promise.all([
                fetch('/assets/static/tutorial-content.json').then(res => res.json()),
                fetch('/assets/static/metrics-catalog.json').then(res => res.json())
            ]).then(([tutData, metData]) => {
                tutorialData = tutData;
                window.metricsCatalog = metData;
                console.log("Tutorial and Metrics catalogs loaded successfully.");
                if (editor) {
                    initializeTutorial(); // Initialize tutorial manager now that data is ready
                    validateJSON();
                }
            }).catch(error => {
                console.error("Error loading initial data:", error);
            });
            let autoRender = true;
            let currentSimulationData = null;

            // Scroll to validation section
            document.addEventListener("click", function (e) {
                if (e.target && e.target.id === "scroll-to-validation-btn") {
                    const validationPanel =
                        document.querySelector(".validation-panel");
                    if (validationPanel) {
                        validationPanel.scrollIntoView({ behavior: "smooth" });
                    }
                }
                if (e.target && e.target.id === "scroll-to-top-btn") {
                    window.scrollTo({ top: 0, behavior: "smooth" });
                }
            });

            // History system for undo functionality
            let history = [];
            let historyIndex = -1;
            const MAX_HISTORY = 50;

            // Drag and drop state
            let isDragging = false;
            let draggedTask = null;
            let dragStartX = 0;
            let dragStartY = 0;
            let originalTaskData = null;

            // Resize state
            let isResizing = false;
            let resizeType = null; // 'left' or 'right'
            let resizeHandle = null;
            let originalDuration = 0;
            let originalStartTime = null;
            let durationPreview = null;

            // Sample simulation data with resources
            const sampleSimulation = {
                simulation: {
                    meta: {
                        id: "sim_breadmaking_v3_full",
                        article_title: "Artisan Bread Making Process",
                        domain: "Bakery Operations",
                    },
                    config: {
                        time_unit: "minute",
                        start_time: "06:00",
                        end_time: "18:00",
                    },
                    actors: [
                        { id: "baker", role: "Baker", cost_per_hour: 25 },
                        {
                            id: "assistant",
                            role: "Assistant Baker",
                            cost_per_hour: 18,
                        },
                    ],
                    equipment: [
                        {
                            id: "mixer",
                            name: "Stand Mixer",
                            emoji: "üåÄ",
                            state: "clean",
                        },
                        {
                            id: "oven",
                            name: "Commercial Oven",
                            emoji: "üî•",
                            state: "available",
                        },
                        {
                            id: "workspace",
                            name: "Prep Counter",
                            emoji: "üè¢",
                            state: "clean",
                        },
                        {
                            id: "mixing_bowl",
                            name: "Mixing Bowl",
                            emoji: "ü•£",
                            state: "clean",
                        },
                    ],
                    resources: [
                        {
                            id: "flour",
                            unit: "kg",
                            starting_stock: 50,
                            emoji: "üåæ",
                        },
                        {
                            id: "water",
                            unit: "liter",
                            starting_stock: 20,
                            emoji: "üíß",
                        },
                        {
                            id: "yeast",
                            unit: "g",
                            starting_stock: 500,
                            emoji: "ü¶†",
                        },
                        {
                            id: "mixed_dough",
                            unit: "batch",
                            starting_stock: 0,
                            emoji: "Îç©",
                        },
                        {
                            id: "risen_dough",
                            unit: "batch",
                            starting_stock: 0,
                            emoji: "üçû",
                        },
                        {
                            id: "shaped_loaves",
                            unit: "loaves",
                            starting_stock: 0,
                            emoji: "ü•ñ",
                        },
                        {
                            id: "baked_bread",
                            unit: "loaves",
                            starting_stock: 0,
                            emoji: "üçû",
                        },
                    ],
                    tasks: [
                        {
                            id: "prepare_ingredients üî∏ üîß",
                            actor_id: "baker",
                            start: "06:15",
                            duration: 30,
                            consumes: {},
                            produces: {},
                            depends_on: [],
                            equipment_interactions: [
                                {
                                    id: "workspace",
                                    from_state: "clean",
                                    to_state: "in-use",
                                },
                            ],
                        },
                        {
                            id: "measure_flour üî∏ ‚öñÔ∏è",
                            actor_id: "baker",
                            start: "06:45",
                            duration: 10,
                            consumes: {},
                            produces: {},
                            depends_on: ["prepare_ingredients üî∏ üîß"],
                        },
                        {
                            id: "activate_yeast üî∏ ü¶†",
                            actor_id: "assistant",
                            start: "06:45",
                            duration: 10,
                            consumes: { yeast: 15 },
                            produces: {},
                            depends_on: [],
                        },
                        {
                            id: "mix_dough üî∏ ü•Ñ",
                            actor_id: "baker",
                            start: "06:55",
                            duration: 20,
                            consumes: { flour: 1, water: 0.7 },
                            produces: { mixed_dough: 1 },
                            depends_on: [
                                "measure_flour üî∏ ‚öñÔ∏è",
                                "activate_yeast üî∏ ü¶†",
                            ],
                            equipment_interactions: [
                                {
                                    id: "mixer",
                                    from_state: "clean",
                                    to_state: "dirty",
                                },
                                {
                                    id: "mixing_bowl",
                                    from_state: "clean",
                                    to_state: "dirty",
                                },
                            ],
                        },
                        {
                            id: "knead_dough üî∏ üëã",
                            actor_id: "baker",
                            start: "07:15",
                            duration: 15,
                            consumes: { mixed_dough: 1 },
                            produces: { risen_dough: 1 },
                            depends_on: ["mix_dough üî∏ ü•Ñ"],
                            equipment_interactions: [
                                {
                                    id: "workspace",
                                    from_state: "in-use",
                                    to_state: "dirty",
                                },
                            ],
                        },
                        {
                            id: "first_rise üî∏ ‚è∞",
                            actor_id: "baker",
                            start: "07:30",
                            duration: 90,
                            consumes: { risen_dough: 1 },
                            produces: { risen_dough: 1 },
                            depends_on: ["knead_dough üî∏ üëã"],
                        },
                        {
                            id: "clean_mixing_bowls üî∏ üßº",
                            actor_id: "assistant",
                            start: "07:30",
                            duration: 20,
                            consumes: {},
                            produces: {},
                            depends_on: [],
                            equipment_interactions: [
                                {
                                    id: "mixing_bowl",
                                    from_state: "dirty",
                                    to_state: "clean",
                                },
                            ],
                        },
                        {
                            id: "shape_loaves üî∏ üëê",
                            actor_id: "baker",
                            start: "09:00",
                            duration: 25,
                            consumes: { risen_dough: 1 },
                            produces: { shaped_loaves: 1 },
                            depends_on: ["first_rise üî∏ ‚è∞"],
                            equipment_interactions: [
                                {
                                    id: "workspace",
                                    from_state: "dirty",
                                    to_state: "dirty",
                                },
                            ],
                        },
                        // INTENTIONAL OVERLAP for 'assistant'
                        {
                            id: "prepare_baking_sheets üî∏ üçû",
                            actor_id: "assistant",
                            start: "09:00",
                            duration: 10,
                            consumes: {},
                            produces: {},
                            depends_on: [],
                        },
                        {
                            id: "preheat_oven üî∏ üî•",
                            actor_id: "assistant",
                            start: "09:05",
                            duration: 15,
                            consumes: {},
                            produces: {},
                            depends_on: ["prepare_baking_sheets üî∏ üçû"],
                            equipment_interactions: [
                                {
                                    id: "oven",
                                    from_state: "available",
                                    to_state: "in-use",
                                },
                            ],
                        },
                        // INTENTIONAL LACK OF BUFFER for 'baker'
                        {
                            id: "second_rise üî∏ ‚è∞",
                            actor_id: "baker",
                            start: "09:25",
                            duration: 45,
                            consumes: { shaped_loaves: 1 },
                            produces: { shaped_loaves: 1 },
                            depends_on: ["shape_loaves üî∏ üëê"],
                        },
                        {
                            id: "bake_bread üî∏ üçû",
                            actor_id: "baker",
                            start: "10:10",
                            duration: 35,
                            consumes: { shaped_loaves: 1 },
                            produces: { baked_bread: 1 },
                            depends_on: ["second_rise üî∏ ‚è∞"],
                            equipment_interactions: [
                                {
                                    id: "oven",
                                    from_state: "in-use",
                                    to_state: "available",
                                },
                            ],
                        },
                        {
                            id: "wash_equipment üî∏ üßΩ",
                            actor_id: "assistant",
                            start: "10:10",
                            duration: 35,
                            consumes: {},
                            produces: {},
                            depends_on: [],
                            equipment_interactions: [
                                {
                                    id: "mixer",
                                    from_state: "dirty",
                                    to_state: "clean",
                                },
                            ],
                        },
                    ],
                },
            };

            // History management
            function saveToHistory() {
                const currentValue = editor.getValue();
                if (
                    history.length > 0 &&
                    history[historyIndex] === currentValue
                ) {
                    return;
                }

                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }

                history.push(currentValue);

                if (history.length > MAX_HISTORY) {
                    history.shift();
                } else {
                    historyIndex++;
                }

                updateUndoButton();
            }

            function undo() {
                if (historyIndex > 0) {
                    historyIndex--;
                    const previousValue = history[historyIndex];
                    editor.setValue(previousValue);
                    updateUndoButton();

                    if (autoRender) {
                        debounceRender();
                    }
                    validateJSON();
                }
            }

            function updateUndoButton() {
                const undoBtn = document.getElementById("undo-btn");
                undoBtn.disabled = historyIndex <= 0;
            }

            function initializeTutorial() {
                if (!tutorialData || !editor) return;

                const playgroundElements = {
                    panel: document.getElementById('tutorial-panel'),
                    title: document.getElementById('tutorial-title'),
                    instructions: document.getElementById('tutorial-instructions'),
                    status: document.getElementById('tutorial-status'),
                    nextBtn: document.getElementById('tutorial-next-btn'),
                    prevBtn: document.getElementById('tutorial-prev-btn'),
                    exitBtn: document.getElementById('tutorial-exit-btn')
                };

                tutorialManager = new TutorialManager(tutorialData, editor, playgroundElements);

                document.getElementById('start-tutorial-btn').addEventListener('click', (e) => {
                    e.preventDefault();
                    document.querySelector('.dropdown-content').style.display = 'none'; // Hide dropdown
                    tutorialManager.start();
                });
            }

            // Task click to scroll functionality
            function scrollToTaskInJSON(taskId) {
                const jsonText = editor.getValue();
                const lines = jsonText.split("\n");

                let targetLine = -1;
                for (let i = 0; i < lines.length; i++) {
                    if (
                        lines[i].includes(taskId) &&
                        lines[i].includes('"id"')
                    ) {
                        targetLine = i + 1;
                        break;
                    }
                }

                if (targetLine > 0) {
                    editor.revealLineInCenter(targetLine);

                    const range = new monaco.Range(
                        targetLine,
                        1,
                        targetLine,
                        1,
                    );
                    const decoration = editor.createDecorationsCollection([
                        {
                            range: range,
                            options: {
                                isWholeLine: true,
                                className: "json-highlight",
                            },
                        },
                    ]);

                    setTimeout(() => {
                        decoration.clear();
                    }, 2000);
                }
            }

            // Drag and drop functionality
            function initializeDragAndDrop() {
                document.addEventListener("mousedown", handleMouseDown);
                document.addEventListener("mousemove", handleMouseMove);
                document.addEventListener("mouseup", handleMouseUp);
            }

            function handleMouseDown(e) {
                const taskBlock = e.target.closest(".task-block");
                if (!taskBlock || !taskBlock.dataset.taskId) return;

                // Check if this is a resize operation
                const rect = taskBlock.getBoundingClientRect();
                const relativeX = e.clientX - rect.left;
                const isLeftEdge = relativeX <= 8;
                const isRightEdge = relativeX >= rect.width - 8;

                if (isLeftEdge || isRightEdge) {
                    // Start resize operation
                    isResizing = true;
                    resizeType = isLeftEdge ? "left" : "right";
                    resizeHandle = taskBlock;
                    dragStartX = e.clientX;

                    originalTaskData = {
                        taskId: taskBlock.dataset.taskId,
                        actorId: taskBlock.dataset.actorId,
                        start: taskBlock.dataset.start,
                        duration: parseInt(taskBlock.dataset.duration),
                    };

                    originalDuration = originalTaskData.duration;
                    originalStartTime = originalTaskData.start;

                    // Add resize class
                    taskBlock.classList.add("resizing");

                    // Create duration preview
                    durationPreview = document.createElement("div");
                    durationPreview.className = "duration-preview";
                    durationPreview.textContent = `${originalDuration} min`;
                    taskBlock.appendChild(durationPreview);
                } else {
                    // Set up potential drag but don't commit to dragging yet
                    draggedTask = taskBlock;
                    dragStartX = e.clientX;
                    dragStartY = e.clientY;

                    originalTaskData = {
                        taskId: taskBlock.dataset.taskId,
                        actorId: taskBlock.dataset.actorId,
                        start: taskBlock.dataset.start,
                        duration: parseInt(taskBlock.dataset.duration),
                    };
                }

                e.preventDefault();
            }

            function handleMouseMove(e) {
                if (isResizing && resizeHandle) {
                    // Handle resize operation
                    const deltaX = e.clientX - dragStartX;
                    const track = resizeHandle.closest(".task-track");
                    const trackRect = track.getBoundingClientRect();
                    const totalMinutes =
                        currentSimulationData.total_duration_minutes;

                    let newDuration = originalDuration;
                    let newStartTime = originalStartTime;

                    if (resizeType === "right") {
                        // Resize from right edge - change duration
                        const deltaMinutes = Math.round(
                            (deltaX / trackRect.width) * totalMinutes,
                        );
                        newDuration = Math.max(
                            15,
                            originalDuration + deltaMinutes,
                        ); // Minimum 15 minutes
                    } else if (resizeType === "left") {
                        // Resize from left edge - change start time and duration
                        const deltaMinutes = Math.round(
                            (deltaX / trackRect.width) * totalMinutes,
                        );
                        const [hours, mins] = originalStartTime
                            .split(":")
                            .map(Number);
                        const originalStartMinutes = hours * 60 + mins;
                        const newStartMinutes = Math.max(
                            currentSimulationData.start_time_minutes,
                            originalStartMinutes + deltaMinutes,
                        );

                        newDuration = Math.max(
                            15,
                            originalDuration - deltaMinutes,
                        );
                        const newHours = Math.floor(newStartMinutes / 60);
                        const newMins = newStartMinutes % 60;
                        newStartTime = `${newHours.toString().padStart(2, "0")}:${newMins.toString().padStart(2, "0")}`;

                        // Update visual position for left resize
                        const startPercentage =
                            ((newStartMinutes -
                                currentSimulationData.start_time_minutes) /
                                totalMinutes) *
                            100;
                        resizeHandle.style.left = startPercentage + "%";
                    }

                    // Update preview
                    if (durationPreview) {
                        durationPreview.textContent = `${newDuration} min`;
                    }

                    // Update visual size
                    const newPercentage = (newDuration / totalMinutes) * 100;
                    resizeHandle.style.width = newPercentage + "%";

                    return;
                }

                if (!draggedTask) return;

                e.preventDefault();
                const deltaX = e.clientX - dragStartX;
                const deltaY = e.clientY - dragStartY;

                if (Math.abs(deltaX) > 2 || Math.abs(deltaY) > 2) {
                    // Now we're actually dragging
                    if (!isDragging) {
                        isDragging = true;
                        e.preventDefault();
                    }

                    if (!draggedTask.classList.contains("dragging")) {
                        // Store original dimensions only when we start dragging
                        const rect = draggedTask.getBoundingClientRect();
                        draggedTask.classList.add("dragging");
                        draggedTask.style.position = "fixed";
                        draggedTask.style.width = rect.width + "px";
                        draggedTask.style.height = rect.height + "px";
                        draggedTask.style.zIndex = "1000";
                    }

                    draggedTask.style.left =
                        e.clientX -
                        parseInt(draggedTask.style.width) / 2 +
                        "px";
                    draggedTask.style.top =
                        e.clientY -
                        parseInt(draggedTask.style.height) / 2 +
                        "px";

                    // Highlight drop zones only during actual drag
                    const taskTracks = document.querySelectorAll(".task-track");
                    taskTracks.forEach((track) => {
                        const rect = track.getBoundingClientRect();
                        if (
                            e.clientX >= rect.left &&
                            e.clientX <= rect.right &&
                            e.clientY >= rect.top &&
                            e.clientY <= rect.bottom
                        ) {
                            track.classList.add("drop-zone");
                        } else {
                            track.classList.remove("drop-zone", "invalid");
                        }
                    });
                }
            }

            function handleMouseUp(e) {
                if (isResizing && resizeHandle) {
                    // Handle resize completion
                    const deltaX = e.clientX - dragStartX;
                    const track = resizeHandle.closest(".task-track");
                    const trackRect = track.getBoundingClientRect();
                    const totalMinutes =
                        currentSimulationData.total_duration_minutes;

                    let newDuration = originalDuration;
                    let newStartTime = originalStartTime;

                    if (resizeType === "right") {
                        const deltaMinutes = Math.round(
                            (deltaX / trackRect.width) * totalMinutes,
                        );
                        newDuration = Math.max(
                            15,
                            originalDuration + deltaMinutes,
                        );
                    } else if (resizeType === "left") {
                        const deltaMinutes = Math.round(
                            (deltaX / trackRect.width) * totalMinutes,
                        );
                        const [hours, mins] = originalStartTime
                            .split(":")
                            .map(Number);
                        const originalStartMinutes = hours * 60 + mins;
                        const newStartMinutes = Math.max(
                            currentSimulationData.start_time_minutes,
                            originalStartMinutes + deltaMinutes,
                        );

                        newDuration = Math.max(
                            15,
                            originalDuration - deltaMinutes,
                        );
                        const newHours = Math.floor(newStartMinutes / 60);
                        const newMins = newStartMinutes % 60;
                        newStartTime = `${newHours.toString().padStart(2, "0")}:${newMins.toString().padStart(2, "0")}`;
                    }

                    // Update JSON with new duration and/or start time
                    updateTaskDurationInJSON(
                        originalTaskData.taskId,
                        newDuration,
                        newStartTime,
                    );

                    // Clean up resize state
                    resizeHandle.classList.remove("resizing");
                    if (durationPreview) {
                        durationPreview.remove();
                        durationPreview = null;
                    }

                    isResizing = false;
                    resizeType = null;
                    resizeHandle = null;
                    originalTaskData = null;
                    return;
                }

                if (!draggedTask) return;

                const taskTracks = document.querySelectorAll(".task-track");
                taskTracks.forEach((track) =>
                    track.classList.remove("drop-zone", "invalid"),
                );

                if (isDragging && draggedTask.classList.contains("dragging")) {
                    // This was a drag operation
                    const targetTrack = document
                        .elementFromPoint(e.clientX, e.clientY)
                        ?.closest(".task-track");
                    if (targetTrack && targetTrack.dataset.actorId) {
                        const newActorId = targetTrack.dataset.actorId;
                        // Adjust cursor position to account for block center being at cursor
                        const blockWidth =
                            parseInt(draggedTask.style.width) || 0;
                        const adjustedX = e.clientX - blockWidth / 2;
                        const newTime = calculateNewTimeFromPosition(
                            adjustedX,
                            targetTrack,
                        );

                        // Always update the JSON - remove overlap prevention
                        updateTaskInJSON(
                            originalTaskData.taskId,
                            newActorId,
                            newTime,
                        );
                    }

                    // Reset drag state
                    draggedTask.classList.remove("dragging");
                    draggedTask.style.position = "";
                    draggedTask.style.left = "";
                    draggedTask.style.top = "";
                    draggedTask.style.width = "";
                    draggedTask.style.height = "";
                    draggedTask.style.zIndex = "";
                } else if (!isDragging) {
                    // This was a click - handle the jump to JSON
                    scrollToTaskInJSON(originalTaskData.taskId);
                }

                isDragging = false;
                draggedTask = null;
                originalTaskData = null;
            }

            function calculateNewTimeFromPosition(clientX, trackElement) {
                const rect = trackElement.getBoundingClientRect();
                const percentage = (clientX - rect.left) / rect.width;

                if (currentSimulationData) {
                    const totalMinutes =
                        currentSimulationData.total_duration_minutes;
                    const minutesFromStart = Math.round(
                        percentage * totalMinutes,
                    );
                    const actualStartTime =
                        currentSimulationData.start_time_minutes +
                        minutesFromStart;

                    const hours = Math.floor(actualStartTime / 60);
                    const mins = actualStartTime % 60;
                    return `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}`;
                }
                return "06:00";
            }

            function updateTaskInJSON(taskId, newActorId, newTime) {
                try {
                    const simulation = JSON.parse(editor.getValue());
                    const task = simulation.simulation.tasks.find(
                        (t) => t.id === taskId,
                    );
                    if (task) {
                        saveToHistory();
                        task.actor_id = newActorId;
                        task.start = newTime;
                        editor.setValue(JSON.stringify(simulation, null, 2));
                        debounceRender();
                    }
                } catch (e) {
                    console.error("Error updating task:", e);
                }
            }

            function updateTaskDurationInJSON(
                taskId,
                newDuration,
                newStartTime,
            ) {
                try {
                    const simulation = JSON.parse(editor.getValue());
                    const task = simulation.simulation.tasks.find(
                        (t) => t.id === taskId,
                    );
                    if (task) {
                        saveToHistory();
                        task.duration = newDuration;
                        if (newStartTime !== null) {
                            task.start = newStartTime;
                        }
                        editor.setValue(JSON.stringify(simulation, null, 2));
                        debounceRender();
                    }
                } catch (e) {
                    console.error("Error updating task duration:", e);
                }
            }

            // Dialog management functions
            function openDialog(title, content) {
                const overlay = document.getElementById("dialog-overlay");
                const dialogContent = document.getElementById("dialog-content");

                dialogContent.innerHTML = `
                    <h3>${title}</h3>
                    ${content}
                `;

                overlay.style.display = "flex";
            }

            function closeDialog() {
                const overlay = document.getElementById("dialog-overlay");
                overlay.style.display = "none";
            }

            function generateId(prefix) {
                return `${prefix}_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
            }

            function openAddTaskDialog() {
                // Try to get existing data, fallback to empty arrays
                let actors = [];
                let resources = [];

                try {
                    const simulation = JSON.parse(editor.getValue());
                    actors = simulation.simulation?.actors || [];
                    resources = simulation.simulation?.resources || [];
                } catch (e) {
                    // If JSON is invalid or empty, use empty arrays
                }

                const actorOptions = actors
                    .map(
                        (actor) =>
                            `<option value="${actor.id}">${actor.role}</option>`,
                    )
                    .join("");

                const resourceCheckboxes = resources
                    .map(
                        (resource) =>
                            `<label style="display: flex; align-items: center; gap: 0.5rem;">
                        <input type="checkbox" value="${resource.id}" name="uses_resources">
                        ${resource.emoji} ${resource.name}
                    </label>`,
                    )
                    .join("");

                const content = `
                    <form class="dialog-form" onsubmit="addTask(event)">
                        <div class="dialog-field">
                            <label>Task Name</label>
                            <input type="text" name="task_name" required placeholder="e.g., Mix dough">
                        </div>
                        <div class="dialog-field">
                            <label>Emoji</label>
                            <input type="text" name="emoji" placeholder="ü•Ñ" maxlength="2">
                        </div>
                        <div class="dialog-field">
                            <label>Assigned Actor</label>
                            <select name="actor_id" required>
                                <option value="">Select an actor...</option>
                                ${actorOptions}
                            </select>
                        </div>
                        <div class="dialog-field">
                            <label>Start Time</label>
                            <input type="time" name="start_time" required value="06:00">
                        </div>
                        <div class="dialog-field">
                            <label>Duration (minutes)</label>
                            <input type="number" name="duration" required min="1" value="30">
                        </div>
                        <div class="dialog-field">
                            <label>Uses Resources</label>
                            <div style="display: flex; flex-direction: column; gap: 0.5rem; max-height: 150px; overflow-y: auto;">
                                ${resourceCheckboxes}
                            </div>
                        </div>
                        <div class="dialog-buttons">
                            <button type="button" class="btn-secondary" onclick="closeDialog()">Cancel</button>
                            <button type="submit" class="btn-primary">Add Task</button>
                        </div>
                    </form>
                `;

                openDialog("Add New Task", content);
            }

            function openAddActorDialog() {
                const content = `
                    <form class="dialog-form" onsubmit="addActor(event)">
                        <div class="dialog-field">
                            <label>Actor ID</label>
                            <input type="text" name="actor_id" required placeholder="e.g., chef, assistant" pattern="[a-z_]+" title="Use lowercase letters and underscores only">
                        </div>
                        <div class="dialog-field">
                            <label>Role/Title</label>
                            <input type="text" name="role" required placeholder="e.g., Head Chef">
                        </div>
                        <div class="dialog-field">
                            <label>Cost per Hour ($)</label>
                            <input type="number" name="cost_per_hour" required min="0" step="0.01" value="25.00">
                        </div>
                        <div class="dialog-buttons">
                            <button type="button" class="btn-secondary" onclick="closeDialog()">Cancel</button>
                            <button type="submit" class="btn-primary">Add Actor</button>
                        </div>
                    </form>
                `;

                openDialog("Add New Actor", content);
            }

            function openAddResourceDialog() {
                const content = `
                    <form class="dialog-form" onsubmit="addResource(event)">
                        <div class="dialog-field">
                            <label>Resource ID</label>
                            <input type="text" name="resource_id" required placeholder="e.g., mixer, oven" pattern="[a-z_]+" title="Use lowercase letters and underscores only">
                        </div>
                        <div class="dialog-field">
                            <label>Display Name</label>
                            <input type="text" name="name" required placeholder="e.g., Stand Mixer">
                        </div>
                        <div class="dialog-field">
                            <label>Emoji</label>
                            <input type="text" name="emoji" required placeholder="ü•Ñ" maxlength="2">
                        </div>
                        <div class="dialog-field">
                            <label>Initial State</label>
                            <select name="state" required>
                                <option value="clean">Clean</option>
                                <option value="dirty">Dirty</option>
                                <option value="available">Available</option>
                                <option value="in-use">In Use</option>
                                <option value="maintenance">Maintenance</option>
                            </select>
                        </div>
                        <div class="dialog-field">
                            <label>Capacity</label>
                            <input type="number" name="capacity" required min="1" value="1">
                        </div>
                        <div class="dialog-buttons">
                            <button type="button" class="btn-secondary" onclick="closeDialog()">Cancel</button>
                            <button type="submit" class="btn-primary">Add Resource</button>
                        </div>
                    </form>
                `;

                openDialog("Add New Resource", content);
            }

            function addTask(event) {
                event.preventDefault();
                const form = event.target;
                const formData = new FormData(form);

                const taskName = formData.get("task_name");
                const emoji = formData.get("emoji") || "üìù";
                const taskId = `${taskName.toLowerCase().replace(/\s+/g, "_")} üî∏ ${emoji}`;

                const usesResources = Array.from(
                    form.querySelectorAll(
                        'input[name="uses_resources"]:checked',
                    ),
                ).map((cb) => cb.value);

                const newTask = {
                    id: taskId,
                    actor_id: formData.get("actor_id"),
                    start: formData.get("start_time"),
                    duration: parseInt(formData.get("duration")),
                    uses_resources: usesResources,
                };

                try {
                    let simulation;
                    const jsonText = editor.getValue().trim();

                    if (!jsonText) {
                        // Create a new simulation if editor is empty
                        simulation = {
                            simulation: {
                                time_unit: "minute",
                                start_time: "06:00",
                                end_time: "18:00",
                                actors: [],
                                resources: [],
                                tasks: [],
                            },
                        };
                    } else {
                        simulation = JSON.parse(jsonText);
                        if (!simulation.simulation) {
                            simulation.simulation = {};
                        }
                        if (!simulation.simulation.tasks) {
                            simulation.simulation.tasks = [];
                        }
                    }

                    simulation.simulation.tasks.push(newTask);

                    saveToHistory();
                    editor.setValue(JSON.stringify(simulation, null, 2));
                    debounceRender();
                    closeDialog();
                } catch (e) {
                    alert("Error adding task: " + e.message);
                }
            }

            function addActor(event) {
                event.preventDefault();
                const form = event.target;
                const formData = new FormData(form);

                const newActor = {
                    id: formData.get("actor_id"),
                    role: formData.get("role"),
                    cost_per_hour: parseFloat(formData.get("cost_per_hour")),
                };

                try {
                    let simulation;
                    const jsonText = editor.getValue().trim();

                    if (!jsonText) {
                        // Create a new simulation if editor is empty
                        simulation = {
                            simulation: {
                                time_unit: "minute",
                                start_time: "06:00",
                                end_time: "18:00",
                                actors: [],
                                resources: [],
                                tasks: [],
                            },
                        };
                    } else {
                        simulation = JSON.parse(jsonText);
                        if (!simulation.simulation) {
                            simulation.simulation = {};
                        }
                        if (!simulation.simulation.actors) {
                            simulation.simulation.actors = [];
                        }
                    }

                    simulation.simulation.actors.push(newActor);

                    saveToHistory();
                    editor.setValue(JSON.stringify(simulation, null, 2));
                    debounceRender();
                    closeDialog();
                } catch (e) {
                    alert("Error adding actor: " + e.message);
                }
            }

            function addResource(event) {
                event.preventDefault();
                const form = event.target;
                const formData = new FormData(form);

                const newResource = {
                    id: formData.get("resource_id"),
                    name: formData.get("name"),
                    emoji: formData.get("emoji"),
                    state: formData.get("state"),
                    capacity: parseInt(formData.get("capacity")),
                    current_usage: 0,
                };

                try {
                    let simulation;
                    const jsonText = editor.getValue().trim();

                    if (!jsonText) {
                        // Create a new simulation if editor is empty
                        simulation = {
                            simulation: {
                                time_unit: "minute",
                                start_time: "06:00",
                                end_time: "18:00",
                                actors: [],
                                resources: [],
                                tasks: [],
                            },
                        };
                    } else {
                        simulation = JSON.parse(jsonText);
                        if (!simulation.simulation) {
                            simulation.simulation = {};
                        }
                        if (!simulation.simulation.resources) {
                            simulation.simulation.resources = [];
                        }
                    }

                    simulation.simulation.resources.push(newResource);

                    saveToHistory();
                    editor.setValue(JSON.stringify(simulation, null, 2));
                    debounceRender();
                    closeDialog();
                } catch (e) {
                    alert("Error adding resource: " + e.message);
                }
            }

            function toggleFullscreen() {
                const jsonPanel = document.querySelector(".json-editor-panel");
                const simulationPanel =
                    document.querySelector(".simulation-panel");
                const fullscreenBtn = document.getElementById("fullscreen-btn");

                if (jsonPanel.classList.contains("hidden")) {
                    jsonPanel.classList.remove("hidden");
                    simulationPanel.classList.remove("fullscreen");
                    fullscreenBtn.innerHTML = "‚õ∂";
                    fullscreenBtn.title = "Toggle fullscreen simulation view";
                } else {
                    jsonPanel.classList.add("hidden");
                    simulationPanel.classList.add("fullscreen");
                    fullscreenBtn.innerHTML = "‚õó";
                    fullscreenBtn.title = "Show JSON editor";
                }
            }

            // Static page structure from structure.txt file
            async function fetchPageStructure() {
                try {
                    const response = await fetch("/assets/data/structure.txt");
                    if (!response.ok) {
                        throw new Error("Failed to fetch structure.txt");
                    }

                    const text = await response.text();
                    const lines = text.trim().split("\n");
                    const structure = {};

                    lines.forEach((line) => {
                        const parts = line.trim().split("/");
                        if (parts.length === 3) {
                            const [domain, subcategory, page] = parts;

                            if (!structure[domain]) {
                                structure[domain] = {};
                            }
                            if (!structure[domain][subcategory]) {
                                structure[domain][subcategory] = [];
                            }
                            structure[domain][subcategory].push(page);
                        }
                    });

                    return structure;
                } catch (e) {
                    console.error("Failed to load page structure:", e);
                    // Basic fallback
                    return {
                        "food-production": {
                            baking: ["breadmaking", "breadmaking-alpha"],
                        },
                    };
                }
            }

            function cleanDisplayName(name) {
                return name
                    .split("-")
                    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
                    .join(" ");
            }

            function openSubmitDialog() {
                const content = `
                    <div class="submit-dialog">
                        <form class="dialog-form" onsubmit="handleSubmit(event)">
                            <div class="cascade-container">
                                <div class="dialog-field">
                                    <label>Domain</label>
                                    <select name="domain" id="domain-select" onchange="updateSubcategories()" required>
                                        <option value="">Select a domain...</option>
                                        <option value="entertainment">Entertainment</option>
                                        <option value="food-production">Food Production</option>
                                        <option value="healthcare">Healthcare</option>
                                        <option value="manufacturing">Manufacturing</option>
                                        <option value="technology">Technology</option>
                                        <option value="transportation">Transportation</option>
                                    </select>
                                </div>

                                <div class="dialog-field cascade-dropdown" id="subcategory-field">
                                    <label>Subcategory</label>
                                    <select name="subcategory" id="subcategory-select" onchange="updatePages()" required>
                                        <option value="">Select a subcategory...</option>
                                    </select>
                                </div>

                                <div class="dialog-field cascade-dropdown" id="page-field">
                                    <label>Page</label>
                                    <select name="page" id="page-select" onchange="updatePreview()" required>
                                        <option value="">Select a page...</option>
                                    </select>
                                </div>

                                <div id="path-preview" class="page-path-preview" style="display: none;">
                                    <strong>Target:</strong> <span id="preview-path"></span>
                                </div>
                            </div>

                            <div class="dialog-buttons">
                                <button type="button" class="btn-secondary" onclick="closeDialog()">Cancel</button>
                                <button type="submit" class="btn-primary" disabled id="submit-confirm-btn">Submit</button>
                            </div>
                        </form>
                    </div>
                `;

                openDialog("Submit Simulation", content);

                // Load page structure from static file
                fetchPageStructure()
                    .then((structure) => {
                        window.pageStructure = structure;
                        console.log("Page structure loaded successfully");
                    })
                    .catch((e) => {
                        console.error("Failed to load page structure:", e);
                        window.pageStructure = {
                            "food-production": {
                                baking: ["breadmaking", "breadmaking-alpha"],
                            },
                        };
                    });
            }

            function updateSubcategories() {
                const domainSelect = document.getElementById("domain-select");
                const subcategoryField =
                    document.getElementById("subcategory-field");
                const subcategorySelect =
                    document.getElementById("subcategory-select");
                const pageField = document.getElementById("page-field");

                const selectedDomain = domainSelect.value;

                // Clear subcategory options
                subcategorySelect.innerHTML =
                    '<option value="">Select a subcategory...</option>';

                if (
                    selectedDomain &&
                    window.pageStructure &&
                    window.pageStructure[selectedDomain]
                ) {
                    const subcategories = Object.keys(
                        window.pageStructure[selectedDomain],
                    );
                    subcategories.sort().forEach((subcat) => {
                        const option = document.createElement("option");
                        option.value = subcat;
                        option.textContent = cleanDisplayName(subcat);
                        subcategorySelect.appendChild(option);
                    });

                    subcategoryField.classList.add("visible");
                } else {
                    subcategoryField.classList.remove("visible");
                }

                // Hide page field
                pageField.classList.remove("visible");
                updatePreview();
            }

            function updatePages() {
                const domainSelect = document.getElementById("domain-select");
                const subcategorySelect =
                    document.getElementById("subcategory-select");
                const pageField = document.getElementById("page-field");
                const pageSelect = document.getElementById("page-select");

                const selectedDomain = domainSelect.value;
                const selectedSubcategory = subcategorySelect.value;

                // Clear page options
                pageSelect.innerHTML =
                    '<option value="">Select a page...</option>';

                if (
                    selectedDomain &&
                    selectedSubcategory &&
                    window.pageStructure &&
                    window.pageStructure[selectedDomain] &&
                    window.pageStructure[selectedDomain][selectedSubcategory]
                ) {
                    const pages =
                        window.pageStructure[selectedDomain][
                            selectedSubcategory
                        ];
                    pages.sort().forEach((page) => {
                        const option = document.createElement("option");
                        option.value = page;
                        option.textContent = cleanDisplayName(page);
                        pageSelect.appendChild(option);
                    });

                    if (pages.length > 0) {
                        pageField.classList.add("visible");

                        // Auto-select if there's a good match for the current simulation
                        const simulationData = getCurrentSimulationData();
                        if (
                            simulationData &&
                            selectedDomain === "food-production" &&
                            selectedSubcategory === "baking"
                        ) {
                            const breadmakingOption = pageSelect.querySelector(
                                'option[value="breadmaking"]',
                            );
                            if (breadmakingOption) {
                                pageSelect.value = "breadmaking";
                                updatePreview();
                            }
                        }
                    }
                } else {
                    pageField.classList.remove("visible");
                }

                updatePreview();
            }

            function updatePreview() {
                const domainSelect = document.getElementById("domain-select");
                const subcategorySelect =
                    document.getElementById("subcategory-select");
                const pageSelect = document.getElementById("page-select");
                const previewDiv = document.getElementById("path-preview");
                const previewPath = document.getElementById("preview-path");
                const submitBtn = document.getElementById("submit-confirm-btn");

                const domain = domainSelect.value;
                const subcategory = subcategorySelect.value;
                const page = pageSelect.value;

                if (domain && subcategory && page) {
                    const fullPath = `${domain}/${subcategory}/${page}`;
                    previewPath.textContent = fullPath;
                    previewDiv.style.display = "block";
                    submitBtn.disabled = false;
                } else {
                    previewDiv.style.display = "none";
                    submitBtn.disabled = true;
                }
            }

            function handleSubmit(event) {
                event.preventDefault();
                const formData = new FormData(event.target);
                const domain = formData.get("domain");
                const subcategory = formData.get("subcategory");
                const page = formData.get("page");

                const targetPath = `${domain}/${subcategory}/${page}`;

                // For now, just show an alert - actual submission logic would go here
                alert(
                    `Simulation would be submitted to: ${targetPath}\n\n(Submission functionality not implemented yet)`,
                );

                closeDialog();
            }

            function getCurrentSimulationData() {
                try {
                    const jsonText = editor.getValue().trim();
                    if (jsonText) {
                        return JSON.parse(jsonText);
                    }
                } catch (e) {
                    // Invalid JSON
                }
                return null;
            }

            function processSimulationData(simulationData) {
                const sim = simulationData.simulation;
                const startTime = sim.start_time || "06:00";
                const [startHour, startMin] = startTime.split(":").map(Number);
                const startTimeMinutes = startHour * 60 + startMin;

                const processedTasks = [];
                let actualEndTime = startTimeMinutes;

                for (const task of sim.tasks || []) {
                    const taskStart = task.start || "00:00";
                    let taskStartMinutes;

                    try {
                        if (taskStart.includes(":")) {
                            let [taskHour, taskMin] = taskStart
                                .split(":")
                                .map(Number);
                            if (taskMin >= 60) {
                                const additionalHours = Math.floor(
                                    taskMin / 60,
                                );
                                taskHour += additionalHours;
                                taskMin = taskMin % 60;
                            }
                            taskStartMinutes = taskHour * 60 + taskMin;
                        } else {
                            taskStartMinutes = startTimeMinutes;
                        }
                    } catch {
                        taskStartMinutes = startTimeMinutes;
                    }

                    const taskDuration = task.duration || 0;
                    const taskEndMinutes = taskStartMinutes + taskDuration;
                    actualEndTime = Math.max(actualEndTime, taskEndMinutes);

                    const processedTask = { ...task };
                    processedTask.start_minutes = taskStartMinutes;
                    processedTask.end_minutes = taskEndMinutes;

                    const taskId = task.id || "";
                    try {
                        if (taskId.includes("üî∏")) {
                            const parts = taskId.split("üî∏");
                            if (parts.length >= 2 && parts[1].trim()) {
                                processedTask.display_name = parts[0].trim();
                                processedTask.emoji = parts[1].trim();
                            } else {
                                processedTask.display_name = taskId;
                                processedTask.emoji = "[TASK]";
                            }
                        } else {
                            processedTask.display_name = taskId;
                            processedTask.emoji = "[TASK]";
                        }
                    } catch (e) {
                        processedTask.display_name = taskId;
                        processedTask.emoji = "[TASK]";
                    }

                    processedTasks.push(processedTask);
                }

                const dynamicEndTime = actualEndTime + 30;
                const totalDuration = dynamicEndTime - startTimeMinutes;

                for (const task of processedTasks) {
                    if (totalDuration > 0) {
                        task.start_percentage =
                            ((task.start_minutes - startTimeMinutes) /
                                totalDuration) *
                            100;
                        task.duration_percentage =
                            ((task.duration || 0) / totalDuration) * 100;
                    } else {
                        task.start_percentage = 0;
                        task.duration_percentage = 0;
                    }
                }

                const actorWorkloads = {};
                const totalAvailableTime = dynamicEndTime - startTimeMinutes;

                for (const task of processedTasks) {
                    const actorId = task.actor_id;
                    const duration = task.duration || 0;
                    actorWorkloads[actorId] =
                        (actorWorkloads[actorId] || 0) + duration;
                }

                const processedActors = [];
                for (const actor of sim.actors || []) {
                    const actorCopy = { ...actor };
                    const workload = actorWorkloads[actor.id] || 0;
                    const utilization =
                        totalAvailableTime > 0
                            ? (workload / totalAvailableTime) * 100
                            : 0;
                    actorCopy.utilization_percentage =
                        Math.round(utilization * 10) / 10;
                    actorCopy.total_work_minutes = workload;
                    processedActors.push(actorCopy);
                }

                const dynamicEndHour = Math.floor(dynamicEndTime / 60);
                const dynamicEndMin = dynamicEndTime % 60;
                const dynamicEndTimeStr = `${dynamicEndHour.toString().padStart(2, "0")}:${dynamicEndMin.toString().padStart(2, "0")}`;

                return {
                    time_unit: sim.time_unit || "minute",
                    start_time: startTime,
                    end_time: dynamicEndTimeStr,
                    start_time_minutes: startTimeMinutes,
                    end_time_minutes: dynamicEndTime,
                    total_duration_minutes: totalDuration,
                    actors: processedActors,
                    equipment: sim.equipment || [],
                    resources: sim.resources || [],
                    tasks: processedTasks,
                    article_title: sim.article_title || "Process Simulation",
                    domain: sim.domain || "General",
                };
            }

            // Render simulation with resources display
            function renderSimulation() {
                const simulationContent =
                    document.getElementById("simulation-content");
                const loadingOverlay =
                    document.getElementById("simulation-loading");

                // Clean up any existing resize state
                if (isResizing && resizeHandle) {
                    resizeHandle.classList.remove("resizing");
                    if (durationPreview) {
                        durationPreview.remove();
                    }
                }
                isResizing = false;
                resizeType = null;
                resizeHandle = null;
                durationPreview = null;
                isDragging = false;
                draggedTask = null;

                if (!validateJSON()) {
                    simulationContent.innerHTML =
                        '<p style="color: var(--error-color); text-align: center; margin-top: 2rem;">Cannot render: JSON validation failed</p>';
                    return;
                }

                try {
                    loadingOverlay.style.display = "flex";
                    const jsonText = editor.getValue();
                    const simulationData = JSON.parse(jsonText);
                    currentSimulationData =
                        processSimulationData(simulationData);

                    simulationContent.innerHTML = "";
                    const container = document.createElement("div");
                    container.className = "simulation-container";

                    const header = document.createElement("div");
                    header.className = "simulation-header";
                    header.innerHTML = `
                        <h4>${currentSimulationData.article_title}</h4>
                        <p>${currentSimulationData.domain} ‚Ä¢ ${currentSimulationData.start_time} - ${currentSimulationData.end_time} (${currentSimulationData.total_duration_minutes} minutes)</p>
                    `;
                    container.appendChild(header);

                    const timeline = document.createElement("div");
                    timeline.className = "simulation-timeline";
                    timeline.style.cssText =
                        "position: relative; min-height: 300px; background: #fff; border: 1px solid var(--border-color); border-radius: var(--border-radius-md); margin: 1rem 0; width: 100%; box-sizing: border-box;";

                    const timeMarkers = document.createElement("div");
                    timeMarkers.className = "timeline-time-markers";
                    timeMarkers.style.cssText =
                        "position: relative; height: 30px; border-bottom: 1px solid var(--border-color); background: #f8f9fa;";

                    const totalMinutes =
                        currentSimulationData.total_duration_minutes;
                    const markerInterval = Math.max(
                        30,
                        Math.ceil(totalMinutes / 8 / 30) * 30,
                    );

                    for (
                        let minutes = 0;
                        minutes <= totalMinutes;
                        minutes += markerInterval
                    ) {
                        const marker = document.createElement("div");
                        marker.className = "time-marker";
                        marker.style.cssText = `position: absolute; left: ${(minutes / totalMinutes) * 100}%; top: 5px; font-size: 0.75rem; color: var(--text-light); transform: translateX(-50%);`;

                        const totalMinutesFromStart =
                            currentSimulationData.start_time_minutes + minutes;
                        const hours = Math.floor(totalMinutesFromStart / 60);
                        const mins = totalMinutesFromStart % 60;
                        marker.textContent = `${hours.toString().padStart(2, "0")}:${mins.toString().padStart(2, "0")}`;

                        timeMarkers.appendChild(marker);
                    }
                    timeline.appendChild(timeMarkers);

                    const actorLanes = document.createElement("div");
                    actorLanes.className = "actor-lanes";
                    actorLanes.style.cssText =
                        "padding: 1rem; width: 100%; box-sizing: border-box;";

                    for (const actor of currentSimulationData.actors) {
                        const lane = document.createElement("div");
                        lane.className = "actor-lane";
                        lane.style.cssText =
                            "display: flex; margin-bottom: 1rem; min-height: 60px; width: 100%; box-sizing: border-box;";

                        const actorLabel = document.createElement("div");
                        actorLabel.className = "actor-label";
                        actorLabel.style.cssText =
                            "width: 150px; padding: 0.5rem; background: var(--bg-light); border-radius: var(--border-radius-sm); margin-right: 1rem; flex-shrink: 0;";
                        actorLabel.innerHTML = `
                            <strong>${actor.role}</strong><br>
                            <small>Utilization: ${actor.utilization_percentage}%</small>
                        `;
                        lane.appendChild(actorLabel);

                        const taskTrack = document.createElement("div");
                        taskTrack.className = "task-track";
                        taskTrack.dataset.actorId = actor.id;
                        taskTrack.style.cssText =
                            "flex: 1; position: relative; background: #f8f9fa; border: 1px solid var(--border-color); border-radius: var(--border-radius-sm); min-height: 40px; width: 100%; box-sizing: border-box;";

                        const actorTasks = currentSimulationData.tasks.filter(
                            (task) => task.actor_id === actor.id,
                        );
                        for (const task of actorTasks) {
                            const taskElement = document.createElement("div");
                            taskElement.className = "task-block";
                            taskElement.dataset.taskId = task.id;
                            taskElement.dataset.actorId = task.actor_id;
                            taskElement.dataset.start = task.start;
                            taskElement.dataset.duration = task.duration;

                            taskElement.style.cssText = `position: absolute; left: ${task.start_percentage}%; width: ${task.duration_percentage}%; height: 30px; top: 5px; background: white; color: black; border: 2px solid var(--primary-color); border-radius: var(--border-radius-sm); font-size: 0.75rem; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center; gap: 0.25rem; padding: 0.25rem 0.5rem; user-select: none;`;

                            taskElement.innerHTML = `<span class="task-emoji">${task.emoji}</span>`;
                            taskElement.title = `${task.display_name} (${task.duration} minutes)`;

                            // Add click event listener as backup for jump functionality
                            taskElement.addEventListener("click", (e) => {
                                // Only handle click if no drag occurred
                                if (!isDragging) {
                                    scrollToTaskInJSON(task.id);
                                }
                            });

                            // Add mousemove event listener for cursor changes on edges
                            taskElement.addEventListener("mousemove", (e) => {
                                if (isResizing || isDragging) return;

                                const rect =
                                    taskElement.getBoundingClientRect();
                                const relativeX = e.clientX - rect.left;
                                const isLeftEdge = relativeX <= 8;
                                const isRightEdge = relativeX >= rect.width - 8;

                                if (isLeftEdge || isRightEdge) {
                                    taskElement.style.cursor = "ew-resize";
                                } else {
                                    taskElement.style.cursor = "pointer";
                                }
                            });

                            // Reset cursor when leaving task block
                            taskElement.addEventListener("mouseleave", () => {
                                if (!isResizing) {
                                    taskElement.style.cursor = "pointer";
                                }
                            });
                            taskTrack.appendChild(taskElement);
                        }

                        lane.appendChild(taskTrack);
                        actorLanes.appendChild(lane);
                    }

                    timeline.appendChild(actorLanes);
                    container.appendChild(timeline);

                    const equipmentAndResourcesContainer =
                        document.createElement("div");
                    // **NEW** Equipment Panel

                    if (currentSimulationData.equipment && currentSimulationData.equipment.length > 0) {
                        // Calculate final equipment states chronologically
                        const finalEquipmentStates = {};
                        currentSimulationData.equipment.forEach(e => {
                            finalEquipmentStates[e.id] = e.state || 'available';
                        });

                        const sortedTasks = [...(currentSimulationData.tasks || [])].sort((a,b) => (a.start || "00:00").localeCompare(b.start || "00:00"));
                        
                        sortedTasks.forEach(task => {
                            (task.equipment_interactions || []).forEach(interaction => {
                                // If the equipment is in the correct starting state...
                                if(finalEquipmentStates[interaction.id] === interaction.from_state) {
                                    //...its new state is the 'to_state', unless it reverts.
                                    finalEquipmentStates[interaction.id] = interaction.revert_after === true ? interaction.from_state : interaction.to_state;
                                }
                            });
                        });

                        const equipmentPanel = document.createElement("div");
                        equipmentPanel.className = "resources-panel";
                        equipmentPanel.innerHTML = `
                <h5>‚öôÔ∏è Equipment (Final States)</h5>
                <div class="resource-grid">
                    ${currentSimulationData.equipment
                        .map(
                            (item) => `
                        <div class="resource-item">
                            <div class="resource-emoji">${item.emoji || "‚ùì"}</div>
                            <div class="resource-info">
                                <div class="resource-name">${item.name || item.id}</div>
                                <div class="resource-state ${finalEquipmentStates[item.id]}">${finalEquipmentStates[item.id]}</div>
                            </div>
                        </div>
                    `,
                        )
                        .join("")}
                </div>
            `;
                        equipmentAndResourcesContainer.appendChild(
                            equipmentPanel,
                        );
                    }

                    // **UPDATED** Resources (Consumables) Panel
                    if (
                        currentSimulationData.resources &&
                        currentSimulationData.resources.length > 0
                    ) {
                        const resourcesPanel = document.createElement("div");
                        resourcesPanel.className = "resources-panel";
                        resourcesPanel.innerHTML = `
                <h5>üì¶ Resources (Consumables)</h5>
                <div class="resource-grid">
                    ${currentSimulationData.resources
                        .map(
                            (resource) => `
                        <div class="resource-item">
                            <div class="resource-emoji">${resource.emoji || "‚ùì"}</div>
                            <div class="resource-info">
                                <div class="resource-name">${resource.id}</div>
                                <div class="resource-state available">Stock: ${resource.starting_stock} ${resource.unit}</div>
                            </div>
                        </div>
                    `,
                        )
                        .join("")}
                </div>
            `;
                        equipmentAndResourcesContainer.appendChild(
                            resourcesPanel,
                        );
                    }

                    container.appendChild(equipmentAndResourcesContainer);

                    const stats = document.createElement("div");
                    stats.className = "simulation-stats";
                    stats.style.cssText =
                        "display: flex; gap: 2rem; padding: 1rem; background: var(--bg-light); border-radius: var(--border-radius-md); margin-top: 1rem;";
                    stats.innerHTML = `
                        <div class="stat-item"><strong>Total Duration:</strong> ${currentSimulationData.total_duration_minutes} minutes</div>
                        <div class="stat-item"><strong>Actors:</strong> ${currentSimulationData.actors.length}</div>
                        <div class="stat-item"><strong>Tasks:</strong> ${currentSimulationData.tasks.length}</div>
                        ${currentSimulationData.resources ? `<div class="stat-item"><strong>Resources:</strong> ${currentSimulationData.resources.length}</div>` : ""}
                    `;
                    container.appendChild(stats);

                    simulationContent.appendChild(container);
                } catch (e) {
                    simulationContent.innerHTML = `<p style="color: var(--error-color); text-align: center; margin-top: 2rem;">Render Error: ${e.message}</p>`;
                    console.error("Render error:", e);
                } finally {
                    loadingOverlay.style.display = "none";
                }
            }

            // Validation functions
            let renderTimeout;
            function debounceRender() {
                clearTimeout(renderTimeout);
                renderTimeout = setTimeout(renderSimulation, 500);
            }

            function updateAutoRenderUI() {
                const renderBtn = document.getElementById(
                    "render-simulation-btn",
                );
                const toggleBtn = document.getElementById("auto-render-toggle");

                if (autoRender) {
                    renderBtn.classList.add("hidden");
                    toggleBtn.textContent = "Auto-render: ON";
                } else {
                    renderBtn.classList.remove("hidden");
                    toggleBtn.textContent = "Auto-render: OFF";
                }
            }

            function validateJSON() {
                const jsonStatus = document.getElementById("json-status");
                const jsonText = editor.getValue();

                if (!jsonText.trim()) {
                    jsonStatus.className = "validation-indicator warning";
                    jsonStatus.textContent = "‚ö† Empty Editor";
                    jsonStatus.title = "Editor is empty";
                    return false;
                }

                try {
                    const parsed = JSON.parse(jsonText);
                    jsonStatus.className = "validation-indicator success";
                    jsonStatus.textContent = "‚úì Valid JSON";
                    jsonStatus.title = "JSON syntax is valid";

                    if (
                        window.metricsCatalog &&
                        window.metricsCatalog.length > 0
                    ) {
                        const validator = new SimulationValidator(parsed);
                        const validationResults = validator.runChecks(
                            window.metricsCatalog,
                        );
                        displayValidationResults(validationResults); // Call the display function
                    }

                    return true;
                } catch (e) {
                    jsonStatus.className = "validation-indicator error";
                    jsonStatus.textContent = `‚úó Invalid JSON: ${e.message}`;
                    jsonStatus.title = `JSON Parse Error: ${e.message}`;
                    return false;
                }
            }

            function displayValidationResults(results) {
                const categoriesContainer = document.getElementById(
                    "validation-categories",
                );

                // Check for a clean run (only success messages)
                const hasIssues = results.some((r) => r.status !== "success");

                if (!hasIssues) {
                    categoriesContainer.innerHTML =
                        '<div class="validation-success" style="text-align: center; padding: 2rem;">üéâ Perfect! No validation issues found.</div>';
                    return;
                }

                // Prepare categories for grouping issues
                const categories = {
                    "Structural Integrity": {
                        id: "critical-errors",
                        results: [],
                    },
                    "Resource Flow": { id: "resource-issues", results: [] },
                    Scheduling: { id: "scheduling-conflicts", results: [] },
                    Optimization: {
                        id: "optimization-suggestions",
                        results: [],
                    },
                };

                // Create a map for quick metric lookup
                const metricMap = new Map(
                    window.metricsCatalog.map((m) => [m.id, m]),
                );

                // Group results by category
                results.forEach((result) => {
                    if (result.status === "success") return; // Don't display success messages in the detailed view

                    const metric = metricMap.get(result.metricId);
                    if (metric && categories[metric.category]) {
                        categories[metric.category].results.push({
                            ...result,
                            severity: metric.severity, // Pass severity for UI styling
                        });
                    }
                });

                let html = "";
                for (const [categoryName, categoryData] of Object.entries(
                    categories,
                )) {
                    if (categoryData.results.length > 0) {
                        html += `
                            <div class="validation-category ${categoryData.id}">
                                <h4>${categoryName} (${categoryData.results.length})</h4>
                                ${categoryData.results
                                    .map(
                                        (result) => `
                                    <div class="validation-issue ${result.severity || "warning"}">
                                        ${result.message}
                                    </div>
                                `,
                                    )
                                    .join("")}
                            </div>
                        `;
                    }
                }
                categoriesContainer.innerHTML = html;
            }

            
            const startBtn = document.getElementById('start-llm-btn');
            
            const infoOverlay = document.getElementById('llm-info-overlay');
            const proceedBtn = document.getElementById('llm-proceed-btn');
            const cancelBtn = document.getElementById('llm-cancel-btn');

            const chatOverlay = document.getElementById('llm-chat-overlay');
            const chatTitle = document.getElementById('llm-chat-title');
            const chatHistory = document.getElementById('llm-chat-history');
            const chatForm = document.getElementById('llm-chat-form');
            const chatInput = document.getElementById('llm-chat-input');
            const thinkingIndicator = document.getElementById('llm-thinking-indicator');
            const chatCloseBtn = document.getElementById('llm-chat-close-btn');

            let aiSession = null;

            // --- Event Listeners ---
            startBtn.addEventListener('click', (e) => {
                e.preventDefault();
                infoOverlay.style.display = 'flex';
            });

            cancelBtn.addEventListener('click', () => infoOverlay.style.display = 'none');
            chatCloseBtn.addEventListener('click', () => chatOverlay.style.display = 'none');

            proceedBtn.addEventListener('click', async () => {
                infoOverlay.style.display = 'none';

                try {
                    const sessionOptions = { topK: 3 };
                    aiSession = await window.ai.createTextSession(sessionOptions);
                    
                    chatTitle.textContent = `Chat with ${aiSession.modelName}`;
                    chatHistory.innerHTML = `<p style="color: var(--text-light);">Session started. Ask a question about the current simulation. For example: "Suggest an improvement."</p>`;
                    chatOverlay.style.display = 'flex';
                } catch (err) {
                    alert(`Error initializing AI session: ${err.message}. Ensure the model has finished downloading.`);
                    console.error(err);
                }
            });

            chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userInput = chatInput.value.trim();
                if (!userInput || !aiSession) return;

                // Append user's message
                appendChatMessage(userInput, 'user');
                chatInput.value = '';
                thinkingIndicator.style.display = 'block';

                try {
                    // Prepend context from the simulation
                    const simulationContext = `Context: The user is viewing a simulation named '${currentSimulationData?.article_title}'. The JSON is: ${editor.getValue()}`;
                    const fullPrompt = `${simulationContext}\n\nUser question: ${userInput}`;
                    
                    const stream = await aiSession.promptStreaming(fullPrompt);
                    
                    // Create a new bubble for the AI response
                    const aiMessageBubble = appendChatMessage('', 'ai');
                    
                    // Stream the response into the bubble
                    for await (const chunk of stream) {
                        aiMessageBubble.textContent += chunk;
                    }

                } catch (err) {
                    appendChatMessage(`Error: ${err.message}`, 'error');
                    console.error(err);
                } finally {
                    thinkingIndicator.style.display = 'none';
                }
            });

            function appendChatMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.style.marginBottom = '0.75rem';
                
                const bubble = document.createElement('p');
                bubble.textContent = text;
                bubble.style.padding = '0.5rem 1rem';
                bubble.style.borderRadius = '12px';
                bubble.style.maxWidth = '80%';
                bubble.style.display = 'inline-block';
                
                if (sender === 'user') {
                    messageDiv.style.textAlign = 'right';
                    bubble.style.backgroundColor = 'var(--primary-color)';
                    bubble.style.color = 'white';
                } else if (sender === 'ai') {
                    bubble.style.backgroundColor = 'var(--bg-light)';
                    bubble.style.color = 'var(--text-color)';
                } else { // error
                     bubble.style.backgroundColor = 'var(--error-color)';
                     bubble.style.color = 'white';
                }
                
                messageDiv.appendChild(bubble);
                chatHistory.appendChild(messageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight; // Auto-scroll
                return bubble; // Return the bubble to stream into it
            }

            function initializeExperimentalLLM() {
            const startBtn = document.getElementById('start-llm-btn');
            
            const infoOverlay = document.getElementById('llm-info-overlay');
            const proceedBtn = document.getElementById('llm-proceed-btn');
            const cancelBtn = document.getElementById('llm-cancel-btn');

            const chatOverlay = document.getElementById('llm-chat-overlay');
            const chatTitle = document.getElementById('llm-chat-title');
            const chatHistory = document.getElementById('llm-chat-history');
            const chatForm = document.getElementById('llm-chat-form');
            const chatInput = document.getElementById('llm-chat-input');
            const thinkingIndicator = document.getElementById('llm-thinking-indicator');
            const chatCloseBtn = document.getElementById('llm-chat-close-btn');

            let llmSession = null;

            // --- Event Listeners ---
            startBtn.addEventListener('click', (e) => {
                e.preventDefault();
                infoOverlay.style.display = 'flex';
            });

            cancelBtn.addEventListener('click', () => infoOverlay.style.display = 'none');
            chatCloseBtn.addEventListener('click', () => {
                if (llmSession && llmSession.destroy) {
                    llmSession.destroy();
                }
                llmSession = null;
                chatOverlay.style.display = 'none';
            });

            proceedBtn.addEventListener('click', async () => {
                infoOverlay.style.display = 'none';

                // The new check is for 'LanguageModel'
                if (!('LanguageModel' in window)) {
                    alert("The Prompt API ('LanguageModel') is not available in your browser. Please ensure you are using Google Chrome Canary and have enabled the required features.");
                    return;
                }

                try {
                    // Check availability first, as recommended
                    const availability = await LanguageModel.availability();
                    if (availability === 'unavailable') {
                         alert("The built-in AI is unavailable on your device. It may not be supported or may have been disabled.");
                         return;
                    }
                    if (availability !== 'available') {
                        alert(`The AI model is currently ${availability}. Please wait for the download to complete and try again.`);
                        return;
                    }

                    // The new API for creating a session
                    llmSession = await LanguageModel.create();
                    
                    chatHistory.innerHTML = `<p style="color: var(--text-light);">Session started. You can now chat with the built-in AI about your current simulation.</p>`;
                    chatOverlay.style.display = 'flex';
                } catch (err) {
                    alert(`Error initializing AI session: ${err.message}.`);
                    console.error(err);
                }
            });

            chatForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                const userInput = chatInput.value.trim();
                if (!userInput || !llmSession) return;

                appendChatMessage(userInput, 'user');
                chatInput.value = '';
                thinkingIndicator.style.display = 'block';
                chatInput.disabled = true;

                try {
                    const simulationContext = `The user is editing a JSON simulation for the Universal Automation Wiki. Here is the current simulation data:\n\n${editor.getValue()}`;
                    
                    // The new API uses promptStreaming on the session object
                    const stream = llmSession.promptStreaming(
                        `Context:\n${simulationContext}\n\nUser Question:\n${userInput}`
                    );
                    
                    const aiMessageBubble = appendChatMessage('', 'ai');
                    
                    // The README provides this exact pattern for streaming
                    for await (const chunk of stream) {
                        aiMessageBubble.textContent += chunk;
                        chatHistory.scrollTop = chatHistory.scrollHeight;
                    }

                } catch (err) {
                    appendChatMessage(`Error: ${err.message}`, 'error');
                    console.error(err);
                } finally {
                    thinkingIndicator.style.display = 'none';
                    chatInput.disabled = false;
                    chatInput.focus();
                }
            });

            function appendChatMessage(text, sender) {
                const messageDiv = document.createElement('div');
                messageDiv.style.marginBottom = '0.75rem';
                
                const bubble = document.createElement('p');
                bubble.textContent = text;
                bubble.style.padding = '0.5rem 1rem';
                bubble.style.borderRadius = '12px';
                bubble.style.maxWidth = '80%';
                bubble.style.display = 'inline-block';
                bubble.style.wordWrap = 'break-word';
                
                if (sender === 'user') {
                    messageDiv.style.textAlign = 'right';
                    bubble.style.backgroundColor = 'var(--primary-color)';
                    bubble.style.color = 'white';
                } else if (sender === 'ai') {
                    bubble.style.backgroundColor = 'var(--bg-light)';
                    bubble.style.color = 'var(--text-color)';
                } else { // error
                     bubble.style.backgroundColor = 'var(--error-color)';
                     bubble.style.color = 'white';
                }
                
                messageDiv.appendChild(bubble);
                chatHistory.appendChild(messageDiv);
                chatHistory.scrollTop = chatHistory.scrollHeight;
                return bubble;
            }
        }

            // Ensure correct initial button visibility
            document.addEventListener("DOMContentLoaded", function () {
                updateAutoRenderUI();
            });

            // Initialize Monaco Editor
            require.config({
                paths: { vs: "https://unpkg.com/monaco-editor@0.44.0/min/vs" },
            });
            require(["vs/editor/editor.main"], function () {
                editor = monaco.editor.create(
                    document.getElementById("json-editor"),
                    {
                        value: JSON.stringify(sampleSimulation, null, 2),
                        language: "json",
                        theme: "vs",
                        automaticLayout: true,
                        minimap: { enabled: false },
                        scrollBeyondLastLine: false,
                        fontSize: 14,
                        lineNumbers: "on",
                        roundedSelection: false,
                        scrollbar: {
                            vertical: "visible",
                            horizontal: "visible",
                        },
                        folding: true,
                        bracketMatching: "always",
                        formatOnPaste: true,
                        formatOnType: true,
                    },
                );

                saveToHistory();

                editor.onDidChangeModelContent(() => {
                    // Always trigger a render if auto-render is on.
                    if (autoRender) {
                        debounceRender();
                    }

                    // Now, decide which validation logic to run.
                    if (tutorialManager && tutorialManager.isActive) {
                        // TUTORIAL MODE: Run step-specific validation logic.
                        tutorialManager.runStepValidation();
                    } else {
                        // NORMAL MODE: Run the full validation suite.
                        validateJSON();
                    }
                });

                let changeTimeout;
                editor.onDidChangeModelContent(() => {
                    clearTimeout(changeTimeout);
                    changeTimeout = setTimeout(() => {
                        saveToHistory();
                    }, 1000);
                });

                validateJSON();
                if (autoRender) {
                    renderSimulation();
                }

                updateAutoRenderUI();
                initializeResizeHandles();
                initializeDragAndDrop();

                initializeTutorial();
                initializeExperimentalLLM();
                validateJSON();
            });

            // Event listeners
            document.getElementById("undo-btn").addEventListener("click", undo);

            document
                .getElementById("load-sample-btn")
                .addEventListener("click", () => {
                    editor.setValue(JSON.stringify(sampleSimulation, null, 2));
                });

            document
                .getElementById("format-json-btn")
                .addEventListener("click", () => {
                    try {
                        const parsed = JSON.parse(editor.getValue());
                        editor.setValue(JSON.stringify(parsed, null, 2));
                    } catch (e) {
                        alert("Cannot format: Invalid JSON");
                    }
                });

            document
                .getElementById("clear-editor-btn")
                .addEventListener("click", () => {
                    if (confirm("Clear the editor?")) {
                        editor.setValue("");
                    }
                });

            document
                .getElementById("render-simulation-btn")
                .addEventListener("click", renderSimulation);

            document
                .getElementById("auto-render-toggle")
                .addEventListener("click", (e) => {
                    autoRender = !autoRender;
                    updateAutoRenderUI();
                    if (autoRender) {
                        renderSimulation();
                    }
                });

            // New action button event listeners
            document
                .getElementById("add-task-btn")
                .addEventListener("click", openAddTaskDialog);

            document
                .getElementById("add-actor-btn")
                .addEventListener("click", openAddActorDialog);

            document
                .getElementById("add-resource-btn")
                .addEventListener("click", openAddResourceDialog);

            document
                .getElementById("fullscreen-btn")
                .addEventListener("click", toggleFullscreen);

            document
                .getElementById("submit-btn")
                .addEventListener("click", openSubmitDialog);

            // Close dialog when clicking outside
            document
                .getElementById("dialog-overlay")
                .addEventListener("click", (e) => {
                    if (e.target.id === "dialog-overlay") {
                        closeDialog();
                    }
                });

            // Keyboard shortcuts
            document.addEventListener("keydown", (e) => {
                if ((e.ctrlKey || e.metaKey) && e.key === "z" && !e.shiftKey) {
                    e.preventDefault();
                    undo();
                }
            });

            // Initialize resize handles
            function initializeResizeHandles() {
                const verticalHandle = document.querySelector(
                    ".resize-handle-vertical",
                );
                const horizontalHandle = document.querySelector(
                    ".resize-handle-horizontal",
                );
                const jsonPanel = document.querySelector(".json-editor-panel");
                const simulationPanel =
                    document.querySelector(".simulation-panel");
                const playgroundTop = document.querySelector(".playground-top");
                const playgroundBottom =
                    document.querySelector(".playground-bottom");
                const playgroundMain =
                    document.querySelector(".playground-main");

                let isDragging = false;
                let dragType = "";

                verticalHandle.addEventListener("mousedown", (e) => {
                    isDragging = true;
                    dragType = "vertical";
                    document.body.style.cursor = "col-resize";
                    e.preventDefault();
                });

                horizontalHandle.addEventListener("mousedown", (e) => {
                    isDragging = true;
                    dragType = "horizontal";
                    document.body.style.cursor = "row-resize";
                    e.preventDefault();
                });

                document.addEventListener("mousemove", (e) => {
                    if (!isDragging) return;
                    e.preventDefault();

                    if (dragType === "vertical") {
                        const containerRect =
                            playgroundTop.getBoundingClientRect();
                        const newWidth =
                            ((e.clientX - containerRect.left) /
                                containerRect.width) *
                            100;

                        // This logic for vertical resizing is fine
                        if (newWidth >= 20 && newWidth <= 80) {
                            jsonPanel.style.width = newWidth + "%";
                            simulationPanel.style.width = 100 - newWidth + "%";
                        }
                    } else if (dragType === "horizontal") {
                        const mainRect = playgroundMain.getBoundingClientRect();
                        const newTopHeight = e.clientY - mainRect.top;

                        // Apply new heights in pixels to forcefully override flex properties.
                        // This also removes the resizing limits as you requested.
                        playgroundTop.style.height = newTopHeight + "px";
                        playgroundBottom.style.height =
                            mainRect.height - newTopHeight + "px";
                    }
                });

                document.addEventListener("mouseup", () => {
                    if (isDragging) {
                        isDragging = false;
                        dragType = "";
                        document.body.style.cursor = "default";
                    }
                });
            }
        </script>
    </body>
</html>
